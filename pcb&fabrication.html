<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>ANDRIDGE MUNENE</title>
        <link rel="stylesheet" href="styles.css">
        <link href="styling.js">
    </head>
    <body>
        <h1>LORA MESH CLOUD FOR ANALOG IOT DEVICES</h1>
    <section id="lorameshcloud">
        <div class="grid-container">
            <div class="item"><img style="max-width: 100%;max-height: auto; object-fit: contain;" src="../Andridge_Munene/images/3D DIAGRAM UPDATE 1.JPG"></div>
            <div class="item"><img style="max-width: 100%;max-height: auto; object-fit: contain;" src="../Andridge_Munene/images/3D DIAGRAM UPDATE 2.JPG"></div>
        </div>
            <p> <b>LORA MESH CLOUD FOR ANALOG SENSORS</b><br>
                It is based on ATMega328 tqfp microprocessor. ICSP programming is need to load the bootloader to the tqfp chip.
                V-USB is used for software-only implementation of a low-speed USB device for Atmel’s AVR® microcontrollers, making it possible to build USB hardware with almost any AVR® microcontroller, not requiring any additional chip. Operating the AVR at higher voltages exceeds the common mode range of many USB chips. Therefore, a voltage regulator from 5v to 3v is needed. If there’s need to run the AVR at 5 V, add 3.6 V zener diodes at D+ and D- to limit the voltage.
                <p><b>Advantages over Microcontrollers with USB Hardware</b><br>
                   •	Standard AVR controllers are usually easier to obtain.
                   •	Most of the controllers with USB support are only available in SMD, which is almost impossible to handle for hobbyists.
                   •	V-USB comes with a free shared Vendor- / Product-ID pair.
                   •	A good free ANSI-C compiler (GNU gcc) and a free development system for Windows (WinAVR) are available for AVR.
                   •	AVR controllers are faster than most of the controllers with integrated USB and cost less.
                   •	Stand-alone operation: Some of the USB controllers download their firmware from the host computer into RAM. They don’t work without connection to the host.
                   •	AVR controllers have on-chip EEPROM.
                </p>
                <p>
                   <b>Advantages over separate USB Peripheral</b><br>
                   •	No additional cost.
                   •	No additional hardware complexity: simpler PCB, less failures.
                   •	No additional power consumption when USB is disconnected. This may be relevant for battery powered devices.
                   •	More freedom in the choice of USB descriptors.
                   •	V-USB comes with a free shared Vendor- / Product-ID pair.
                   •	Little hardware resources used: only two to three I/O pins.
                </p>
                <p>
                   <b>Advantages over other Firmware-Only Implementations</b><br>
                   •	All customizable code written in ANSI-C and thus easier to maintain.
                   •	Modular concept: easier to integrate into existing designs.
                   •	Slightly smaller code size in spite of high level language modules.
                   •	Faster: All encoding/decoding (USB requires NRZI coding and bit stuffing) is done in real-time, not in the main loop after storing away the raw data stream.
                   •	More endpoints, USB descriptors can be better customized.
                   •	V-USB comes with a free shared Vendor- / Product-ID pair.
                   •	The level of standards conformance is documented (description of limitations and potential problems).
                   •	Licensed under the terms of the GNU General Public License or alternatively under a commercial license.
                
                </p>
                
               </p>
           <p><b>LoRa (“long range”) (U3)radio technology.</b><br> It is intended for reliable communication of small amounts of data over long distances (several kilometers). It’s also geared toward low power applications.
            Mesh networking of LoRa nodes. Mesh networking is a network topology where nodes communicate with one another either directly (if they are in range) or indirectly via intermediate nodes. For example, if node 1 wants to send a message to node 2, but is too far away from node 2, the message will automatically be routed via an intermediate node that is in range, say Node 3. </p>
            <p><b>The Radiohead library will be used in this project, because it includes an implementation of mesh networking.</b><br>There is also a transistor as switch if you want to regulate work of LoRa module (RFM95W) with it. When you give signal from digital pin, it will turn on or off</p>
        <p><b>RTC</b> is based on <b>DS3231 chip</b> and can be used for setting alarm for wakeup time of board. It is connected to D2 pin so you can interrupt microprocessor. It is great if you want change wake up intervals from distance. It is possible with downlink messages from TTN server.</p>
        <p>
        <b>The NodeMCU is great for connecting cloud and will be used to send mqtt messages to a TTN server.</b> On nodemcu side we need to receive the messages sent by Arduino over serial. It is powered by 3V.
Arduino will send the messages in JSON format
A 3.3V to 5V logic level shifter with 3.3V for the node MCU board and 5V for the atmega 328p allows for the software serial communication between the two IC’s
        </p>
    
    </section>
    <h1>PID CONTROL SYSTEM FOR BRUSHED MOTORS</h1>
    <section id="brushedmotorquadcopter">
        <div class="grid-container">
            <div class="item"><img style="max-width: 100%;max-height: auto; object-fit: contain;" src="../Andridge_Munene/images/Capture.JPG"></div>
        </div>
        <p>
            <b>CONTROL SYSTEMS</b>
A control system is defined as a system of devices that manages, commands, directs, or regulates the behavior of other devices or systems to achieve a desired result. A control system achieves this through control loops, which are a process designed to maintain a process variable at a desired set point.Simply a system, which controls other systems.
        </p>
        <p>
            <b>Requirements of a control system:</b><br>
<b>Accuracy:</b> Accuracy is the measurement tolerance of the instrument and defines the limits of the errors made when the instrument is used in normal operating conditions.<br>
<b>Sensitivity:</b> The parameters of a control system are always changing with the change in surrounding conditions, internal disturbance, or any other parameters.
This change can be expressed in terms of sensitivity. Any control system should be insensitive to such parameters but sensitive to input signals only.<br>
<b>Noise: </b>An undesired input signal is known as noise. A good control system should be able to reduce the noise effect for better performance.<br>
<b>Stability:</b>It is an important characteristic of the control system. For the bounded input signal, the output must be bounded and if the input is zero then the output must be zero then such a control system is said to be a stable system.<br>
<b>Bandwidth:</b>An operating frequency range decides the bandwidth of the control system. Bandwidth should be as large as possible for the frequency response of a good control system.<br>
<b>Speed:</b>It is the time taken by the control system to achieve its stable output. A good control system possesses high speed. The transient period for such a system is very small.<br>
<b>Oscillation:</b> A small number of oscillations or constant oscillations of output tends to indicate the system to be stable.<br>
        </p>
        <p>
            In any control system, the output is affected due to a change in environmental conditions or any kind of disturbance. So one signal is taken from the output and is fed back to the input.
This signal is compared with a reference input and the error signal is generated. This error signal is applied to the controller and the output is corrected. Such a system is called a feedback system. 
        </p>
        <p>
            When the feedback signal is positive then the system called a positive feedback system. For a positive feedback system, the error signal is the addition of a reference input signal and a feedback signal.
When the feedback signal is negative then the system is called a negative feedback system. For the negative feedback system, the error signal is given by the difference between the reference input signal and the feedback signal.
        </p>
        <p>
            <b>PID CONTROLLER</b><br>
PID (proportional integral derivative) controllers use a control loop feedback mechanism to control process variables and are the most accurate and stable controller.
The output of a PID controller, which is equal to the control input to the plant, is calculated in the time domain from the feedback error 
        </p>
        <p>
            <b>Euler angles & MPU6040 IMU</b><br>

We will have the acceleration of the 3 axes: X, Y and Z, the three dimensions of our 3D space. Let's just call for example, the IMU movement upwards, the Z axis, forward and backward the Y axis and side to side the X axis. Earth's gravity has an acceleration of approx. 9.8 m / s², perpendicular to the ground. Therefore, the IMU also detects the acceleration of terrestrial gravity. But the values that we get from the IMU won't be in "g" units. This module works with 8 bits registers. Each acceleration value is stored in two registers, low and high bits. The sum of this registers give us 16 bits of data. This data will have a maximum of 16 bits so we will have a 2^16=65536 maximum acceleration value including the positive or negative sign. If we read the datasheet of this module we will find that "1g" equals to 16384. So if we read the acceleration value and divide that value to 16384 we obtain the acceleration in "g" units.
        </p>
        <p>
            Thanks to terrestrial gravity you can use the accelerometer readings to know the angle of inclination with respect to the X axis or Y axis
        </p>
        <p>
            <b>Noise & Errors</b><br>
You have to eliminate the noise, the drift and get the accelerometer to not change its angle when it detects a force other than gravity
One of the best is the famous Kálman Filter, which is used in aircraft, rockets and geostationary satellites.Not very practical with an Arduino
Complementary Filter is actually a union of two different filters: a High-pass Filter for the gyroscope and a Low-pass Filter for the Accelerometer. The first lets only pass the values above a certain limit, unlike the Low-pass filter, which only allows those below.
        </p>
        <p>
            <b>PID Code Overview</b><br>
	•	First calculate the error between the desired angle and the real measured angle.<br>
	•	Next the proportional value of the PID is just a proportional constant multiplied by the error<br>
	•	The integral part should only act if we are close to the desired position but we want to fine tune the error. That's why I've made an if operation for an error between -2 and 2 degree. To integrate we just sum the previous integral value with the error multiplied by the integral constant. This will integrate (increase) the value each loop till we reach the 0 point.<br>
	•	The last part is the derivate. The derivate acts upon the speed of the error. As we know the speed is the amount of error that produced in a certain amount of time divided by that time. For that we will use a variable called previous error. We subtract that value from the actual error and divide all by the elapsed time. Finally, we multiply the result by the derivate constant.<br>
	•	The final PID values is the sum of each of this 3 parts.<br>
	•	We know that the min value of PWM signal is 1000us and the max is 2000. So that tells us that the PID value can/s oscillate more than -1000 and 1000 because when we have a value of 2000us the maximum value that we could subtract is 1000 and when we have a value of 1000us for the PWM signal, the maximum value that we could add is 1000 to reach the maximum 2000us<br>
	•	Finally, we calculate the PWM width. We sum the desired throttle and the PID value.<br>
	•	Once again we map the PWM values to be sure that we won't pass the min and max values. Yes, we've already mapped the PID values. But for example, for throttle value of 1300, if we sum the max PID value we would have 2300us and that will mess up the motor.<br>
	•	Finally using the servo function, we create the PWM pulses with the calculated width for each pulse.<br>
	•	Remember to store the previous error.<br>
        </p>
    </section>
    </body>
</html>